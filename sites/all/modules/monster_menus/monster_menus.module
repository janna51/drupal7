<?php

/**
 * @file
 * Menus, menus, menus
 */

require_once 'mm_constants.inc';
require_once 'mm_content.inc';
require_once 'mm_menu.inc';
require_once 'misc.inc';
require_once 'mm_ui.inc';
require_once 'mm_node.inc';
require_once 'mm_static.inc';

/**
 * Implements hook_help().
 */
function monster_menus_help($path, $arg) {
  switch ($path) {
    case 'admin/modules#description':
      return t('Provides a menu system with granular node access.');

    case 'admin/help#monster_menus':
      return t('<p></p>');

    case 'admin/mm/sites':
    case 'admin/mm/sites/list':
      return t('Monster Menus can manage an unlimited number of virtual sites, giving each its own menu tree. Each site can have different overall Drupal settings, but share the same content and Monster Menus permissions. To configure Drupal for multiple sites, see the comments in <code>sites/default/default.settings.php</code>. After setting up a new site, revisit this page using its URL, <strong>Add</strong> a new homepage, and select it as the homepage for the current site.');

    case 'admin/mm/reassign':
      return t('This feature allows you to transfer ownership of all pages and nodes from one user to another. It is most useful when a particular user has been removed or blacklisted from the system.<p><em>This process is irreversible.</em> Only use this feature if you are absolutely sure you know what you are doing.</p>');

    case 'mm/%/contents/add':
      $temp_arg = array('node', 'add', NULL, NULL, NULL);
      if ($arg[4]) {
        $temp_arg[2] = $arg[4];
      }
      break;
  }

  foreach (mm_node_types() as $type) {
    if ('node/add#' . $type['name'] == $path) {
      return $type['description'];
    }
  }

  if ($arg[0] == 'mm' && $arg[2] == 'node') {
    $temp_arg = array_splice($arg, 2);
    $temp_path = drupal_substr($path, drupal_strlen('mm/%/'));
  }

  if (isset($temp_arg)) {
    $output = '';
    if (!isset($temp_path)) $temp_path = join('/', $temp_arg);
    foreach (module_list() as $name) {
      if (module_hook($name, 'help')) {
        // Lookup help for this path.
        if ($help = module_invoke($name, 'help', $temp_path, $temp_arg)) {
          $output .= $help . "\n";
        }
      }
    }
    return $output;
  }
}

/**
 * Implements hook_node_info().
 */
function monster_menus_node_info() {
  return mm_node_types();
}

/**
 * Implements hook_permission().
 */
function monster_menus_permission() {
  $perms = array(
    'administer all groups' => array(
      'title' => t('Administer all Monster Menus groups'),
      'description' => t('Create, read, update membership, and delete all Monster Menus groups'),
      'restrict access' => TRUE,
    ),
    'administer all menus' => array(
      'title' => t('Administer all Monster Menus menus'),
      'description' => t('Create, read, update settings, and delete all Monster Menus pages'),
      'restrict access' => TRUE,
    ),
    'administer all users' => array(
      'title' => t('Administer all Monster Menus user home pages'),
      'description' => t('Create, read, update settings, and delete all Monster Menus user home pages'),
      'restrict access' => TRUE,
    ),
    'see create/modify times' => array(
      'title' => t('See create/modify times'),
      'description' => t('Can see when a page was created and modified, in its settings'),
    ),
    'show/hide post information' => array(
      'title' => t('Show/Hide post information'),
      'description' => t('Allows user to set attribution styles for nodes'),
    ),
    'use permissions solver' => array(
      'title' => t('Use Monster Menus permissions solver'),
      'description' => t('Provides an interface for determining effective page permissions for users'),
    ),
    'use search/replace' => array(
      'title' => t('Use Monster Menus search'),
      'description' => t('Provides an interface to search a part of the Monster Menus tree'),
    ),
    'use tree browser' => array(
      'title' => t('Use Monster Menus tree browser'),
      'description' => t('Provides an interface for viewing the tree, for example when adding a file'),
    ),
    'view all menus' => array(
      'title' => t('View all Monster Menus menus'),
      'description' => t('Allows user to see the entire tree, in read-only mode'),
      'restrict access' => TRUE,
    ),
    'create archives' => array(
      'title' => t('Create Monster Menus archive pages'),
      'description' => t('Move nodes to an archive page when they pass a specified date'),
    ),
    'enable/disable comments' => array(
      'title' => t('Enable and disable comments'),
      'description' => t('Whether a user can turn commenting on or off at the node level'),
    ),
    'propagate node perms' => array(
      'title' => t('Propagate Monster Menus node permissions'),
      'description' => t('When saving Monster Menus page settings, the user can decide to apply permissions to all nodes on the page'),
      'restrict access' => TRUE,
    ),
    'propagate page perms' => array(
      'title' => t('Propagate Monster Menus page permissions'),
      'description' => t('When saving Monster Menus page settings, the user can decide to apply permissions to all sub-pages of the page'),
      'restrict access' => TRUE,
    ),
  );

  foreach (mm_node_types() as $type) {
    $perms = array_merge($perms, $type['perms']);
  }

  if (variable_get('mm_finegrain_comment_readability', FALSE)) {
    foreach (variable_get('mm_comments_readable_labels', array()) as $label)
      $perms[$label['perm']] = array(
        'title' => t('<em>Comment readability:</em> @perm', array('@perm' => $label['desc'])),
      );
    $perms[MM_COMMENT_READABILITY_DEFAULT] = array(
      'title' => t('<em>Comment readability:</em> @perm', array('@perm' => t('can read comments by default'))),
      'description' => t('When no other comment readability setting is applied to a node, roles checked here will be able to read the comments'),
    );
  }

  return $perms;
}

/**
 * Implements hook_menu().
 */
function monster_menus_menu() {
  $items = array();
  foreach (mm_node_types() as $type) {
    $items = array_merge($items, $type['menus']);
  }

  module_load_include('inc', 'monster_menus', 'mm_admin');
  $items = array_merge($items, mm_admin_menu());
  module_load_include('inc', 'monster_menus', 'mm_browser');
  $items = array_merge($items, mm_browser_menu());

  $items['mm-auto'] = array(
    'title' => '',
    'page callback' => 'mm_autocomplete',
    'page arguments' => array(FALSE),
    'access callback' => 'user_access',
    'access arguments' => array('access user profiles'),
    'type' => MENU_CALLBACK);
  $items['mm-txtimg'] = array(
    'title' => '',
    'page callback' => 'mm_text2image_img',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mmsr-get'] = array(
    'title' => '',
    'file' => 'mm_search_replace.inc',
    'page callback' => 'mm_search_result_count',
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);

  if (variable_get('mm_sitemap_max_level', MM_SITEMAP_MAX_LEVEL_DEFAULT) >= 0) {
    $items['-mm-sitemap'] = array(
      'title' => 'Generate sitemap.xml',
      'file' => 'mm_sitemap.inc',
      'page callback' => 'mm_sitemap',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK);
    $items['sitemap.xml'] = array(
      'title' => 'View sitemap.xml',
      'file' => 'mm_sitemap.inc',
      'page callback' => 'mm_sitemap_show',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK);
  }

  // Menu entries to display a page
  $items['mm'] = array(
    'title' => 'Home',
    'page callback' => 'mm_show_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid'] = array(
    'title' => 'View',
    'page_callback' => 'mm_show_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/viewall'] = array(
    'title' => 'View All Users',
    'page callback' => 'mm_show_group',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_group_viewall',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/%/render'] = array(
    'title' => 'Render the node(s) on a page',
    'page callback' => 'mm_render_nodes_on_page',
    'page arguments' => array(1, 2),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, MM_PERMS_READ),
    'type' => MENU_CALLBACK);

  // Local tasks -- Contents tab
  $items['mm/%mm_mmtid/contents'] = array(
    'title' => 'Contents',
    'access callback' => TRUE,
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/add'] = array(
    'title' => 'Add',
    'page callback' => 'mm_ui_node_add',
    'page arguments' => array(1, 4),
    'access callback' => '_mm_menu_access_add',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/view'] = array(
    'title' => 'View',
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/reorder'] = array(
    'title' => 'Reorder',
    'file' => 'mm_ui_node_reorder.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_reorder', 1),
    'access callback' => '_mm_menu_access_node_reorder',
    'access arguments' => array(1),
    'weight' => 3,
    'type' => MENU_LOCAL_TASK);
  // Local tasks -- Settings tab
  $items['mm/%mm_mmtid/settings'] = array(
    'title' => 'Settings',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_settings_tab',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/empty'] = array(
    'title' => 'Empty recycle bin',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'empty'),
    'access callback' => '_mm_menu_access_empty_bin',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/edit'] = array(
    'title' => 'Edit',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'edit'),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/copymove'] = array(
    'title' => 'Copy/Move',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'copymove'),
    'access callback' => '_mm_menu_access_copy',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/restore'] = array(
    'title' => 'Restore',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'restore'),
    'access callback' => '_mm_menu_access_restore',
    'access arguments' => array(1),
    'weight' => 3,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/delete'] = array(
    'title callback' => '_mm_menu_title_settings_delete',
    'title arguments' => array(1),
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'delete'),
    'access callback' => '_mm_menu_access_delete',
    'access arguments' => array(1),
    'weight' => 4,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/sub'] = array(
    'title callback' => '_mm_menu_title_settings_sub',
    'title arguments' => array(1),
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'sub'),
    'access callback' => '_mm_menu_access_sub',
    'access arguments' => array(1),
    'weight' => 5,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/reorder'] = array(
    'title' => 'Reorder menu',
    'file' => 'mm_ui_menu_reorder.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_menu_reorder', 1),
    'access callback' => '_mm_menu_access_menu_reorder',
    'access arguments' => array(1),
    'weight' => 6,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/search'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'weight' => 7,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/search/result'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search result'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/settings/search/result.csv'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search result csv'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/settings/solver'] = array(
    'title' => 'Solve Permissions Issues',
    'file' => 'mm_ui_solver.inc',
    'page callback' => 'mm_ui_solver',
    'page arguments' => array(1, 4),
    'access callback' => '_mm_menu_access_solver',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/listusers/%'] = array(
    'title' => 'List users in a group',
    'page callback' => 'mm_large_group_get_users_json',
    'page arguments' => array(1, 3),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, 'r'),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/listusers/%'] = array(
    'title' => 'List users in a group',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_get_users_json',
    'page arguments' => array(1, 4, 2),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, 'r'),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/deleteusers/%user'] = array(
    'title' => 'Delete user from a group',
    'file' => 'mm_ui_content.inc',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_delete_user',
    'page arguments' => array(1, 2, 4),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/addusers/%'] = array(
    'title' => 'Add users to a group',
    'file' => 'mm_ui_content.inc',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_add_users',
    'page arguments' => array(1, 2, 4),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);

  // Node operations
  $items['mm/%mm_mmtid/node/%node/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'mm_ui_node_edit',
    'page arguments' => array(3),
    'access callback' => 'node_access',
    'access arguments' => array('update', 3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/delete'] = array(
    'title callback' => '_mm_menu_title_node_delete',
    'title arguments' => array(3),
    'file' => 'mm_ui_node_delete.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_delete_confirm', 1, 3),
    'access callback' => '_mm_menu_access_node_delete',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/restore'] = array(
    'title' => 'Restore',
    'file' => 'mm_ui_node_restore.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_restore_confirm', 1, 3),
    'access callback' => '_mm_menu_access_node_restore',
    'access arguments' => array(1, 3),
    'type' => MENU_CALLBACK);
  // Node revisions
  $items['mm/%mm_mmtid/node/%node/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3, 5, 'revert'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3, 5, 'delete'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/view'] = array(
    'title' => 'View a revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3, 5, 'view'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/view/%'] = array(
    'title' => 'Compare revisions',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3, 5, 'compare', 7),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  // alternate version of the above, used in the diff module
  $items['mm/%mm_mmtid/node/%node/revisions/view/%'] = array(
    'title' => 'Compare revisions',
    'load arguments' => array(6),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 3, 6, 'compare', 7),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);

  $items['mm/%mm_mmtid/ajax_node'] = array(
    'title' => 'Get nodes for a page using Ajax call',
    'page callback' => 'mm_content_load_by_ajax',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function monster_menus_menu_alter(&$callbacks) {
  // override the function in user.module
  $callbacks['user/autocomplete'] = array(
    'title' => 'User autocomplete',
    'page callback' => 'mm_autocomplete',
    'page arguments' => array(TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('access user profiles'),
    'type' => MENU_CALLBACK);

  if (isset($callbacks['taxonomy/term/%taxonomy_term'])) {
    // Override a couple of functions in taxonomy.module with our own versions
    // which present only the results the user can see
    $callbacks['taxonomy/term/%taxonomy_term'] = array(
      'title' => 'Taxonomy term',
      'page callback' => 'mm_taxonomy_term_page',
      'page arguments' => array(2),
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'mm_taxonomy.inc',
      'module' => 'monster_menus',
    );
  }

  if (isset($callbacks['taxonomy/term/%taxonomy_term/feed'])) {
    // Override a couple of functions in taxonomy.module with our own versions
    // which present only the results the user can see
    $callbacks['taxonomy/term/%taxonomy_term/feed'] = array(
      'title' => 'Taxonomy term',
      'title callback' => 'taxonomy_term_title',
      'title arguments' => array(2),
      'page callback' => 'mm_taxonomy_term_feed',
      'page arguments' => array(2),
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'mm_taxonomy.inc',
      'module' => 'monster_menus',
    );
  }

  // Remove the default node page, which displays all promoted nodes
  $callbacks['node']['access callback'] = FALSE;

  // The diff module uses a path which becomes longer than MENU_MAX_PARTS, so
  // shorten it to 'mm/%mm_mmtid/node/%node/revisions/view/%', as defined in
  // monster_menus_menu()
  unset($callbacks['node/%node/revisions/view/%/%']);

  if (module_exists('comment')) {
    $callbacks['mm/%mm_mmtid/comment/delete'] = array(
      'title' => 'Delete comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3),
      'access arguments' => array('administer comments'),
      'type' => MENU_CALLBACK,
    );
    $callbacks['mm/%mm_mmtid/comment/edit'] = array(
      'title' => 'Edit comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3),
      'access arguments' => array('post comments'),
      'type' => MENU_CALLBACK,
    );
    $callbacks['mm/%mm_mmtid/comment/reply/%node'] = array(
      'title' => 'Reply to comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3, 4),
      'access callback' => 'node_access',
      'access arguments' => array('view', 4),
      'type' => MENU_CALLBACK,
    );
  }

  // These menu entries rely upon core form functions that need to be loaded
  // from disk when the MM menu entry is called
  $callbacks['mm/%mm_mmtid/contents/add']['file'] = $callbacks['node/add']['file'];
  $callbacks['mm/%mm_mmtid/contents/add']['module'] = $callbacks['node/add']['module'];
  $old_paths = array(
    'node/%node/edit',
    'node/%node/revisions',
    'node/%node/revisions/%/revert',
    'node/%node/revisions/%/delete',
    'comment/delete',
    'comment/edit',
    'comment/reply/%node',
  );
  foreach ($old_paths as $old_path) {
    if (isset($callbacks[$old_path]['file'])) {
      $callbacks["mm/%mm_mmtid/$old_path"]['file'] = $callbacks[$old_path]['file'];
    }

    if (isset($callbacks[$old_path]['module'])) {
      $callbacks["mm/%mm_mmtid/$old_path"]['module'] = $callbacks[$old_path]['module'];
    }
  }

  mm_module_invoke_all_array('mm_menu_alter', array(&$callbacks));

  foreach ($callbacks as $path => $callback) {
    if (!isset($callbacks["mm/%mm_mmtid/$path"]) && (substr_compare('node/', $path, 0, 5) === 0 || substr_compare('comment/', $path, 0, 8) === 0)) {
      if (substr_count($path, '/') + 2 >= MENU_MAX_PARTS) {
        drupal_set_message(t("The menu path @path is too long to be translated by Monster Menus. It may not work properly, depending on the module's code.", array('@path' => $path)));
      }
      else {
        foreach (array('load arguments', 'access arguments', 'page arguments', 'title arguments', 'theme arguments') as $type) {
          if (isset($callback[$type]) && is_array($callback[$type])) {
            foreach ($callback[$type] as $index => $val) {
              if (is_int($val)) {
                $callback[$type][$index] = $val + 2;
              }
            }
          }
        }

        if (isset($callback['page callback']) && $callback['page callback'] == 'node_page_view') {
          $callback['page callback'] = 'mm_node_page_view';
        }

        $callbacks["mm/%mm_mmtid/$path"] = $callback;
        if (preg_match('{^node/%(\w+)(/|$)}', $path)) {
          $callbacks[$path]['page callback'] = '_mm_menu_show_node';
          $callbacks[$path]['page arguments'] = array(1);
          $callbacks[$path]['access callback'] = 'mm_content_user_can_node';
          $callbacks[$path]['access arguments'] = array(1, MM_PERMS_READ);
        }
        else {
          unset($callbacks[$path]);
        }
      }
    }
  }

  // Override the default node delete page
  $callbacks['node/%node/delete'] = array(
    'title callback' => '_mm_menu_title_node_delete',
    'title arguments' => array(1),
    'file' => 'mm_ui_node_delete.inc',
    'module' => 'monster_menus',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_delete_confirm', NULL, 1),
    'access callback' => '_mm_menu_access_node_delete',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK
  );

  // Override the default node revisions page
  $callbacks['node/%node/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK
  );
  if ($callbacks['node/%node/revisions/%/view']['page callback'] == 'node_show') $callbacks['node/%node/revisions/%/view']['page callback'] = 'mm_node_show';

  // Generate the list of keywords that are not allowed in URL aliases, and give
  // an error message if there already is something in mm_tree using one of the
  // menu keywords.
  $checked = $reserved = array();
  foreach ($callbacks as $path => $callback) {
    // Remove leading or trailing slashes, then squish any multiple slashes in a
    // row.
    $path = preg_replace('{//+}', '/', trim($path, '/'));
    $elems = explode('/', $path);
    $failed_elems = array();
    if (!isset($checked[$elems[0]])) {
      $checked[$elems[0]] = mm_content_get(array('alias' => $elems[0]), array(), 10);
    }
    if (!empty($checked[$elems[0]])) {
      $failed_elems[] = $elems[0];
    }

    if (count($elems) >= 3 && $elems[1] == '%mm_mmtid') {
      if (!isset($checked[$elems[2]])) {
        $checked[$elems[2]] = mm_content_get(array('alias' => $elems[0]), array(), 10);
      }
      if (!empty($checked[$elems[2]])) {
        $failed_elems[] = $elems[2];
      }
      else {
        $reserved[$elems[2]] = TRUE;
      }
    }

    foreach ($failed_elems as $elem) {
      $list = array();
      foreach ($checked[$elem] as $tree) {
        $list[] = '&nbsp;&nbsp;' . l(mm_content_expand_name($tree->name), 'mm/' . $tree->mmtid . '/settings');
      }
      $error = 'The menu entry %entry, defined by module %module, contains the element %element. This conflicts with the URL names that are already assigned to these MM pages:<br />!list<br />The menu entry has been disabled. Change either the URL name(s) or the menu path and rebuild the menus.';
      $err_arr = array(
        '%entry' => $path,
        '%module' => $callback['module'],
        '%element' => $elem,
        '!list' => join('<br />', $list),
      );
      if (user_access('administer all menus')) {
        drupal_set_message(t($error, $err_arr), 'error');
      }
      watchdog('mm', $error, $err_arr, WATCHDOG_ERROR);
      unset($callbacks[$path]);
    }

    if (!$failed_elems) {
      $reserved[$elems[0]] = TRUE;
    }
  }
  variable_set('mm_reserved_alias', array_merge(array_keys($reserved), array('feed')));

  // Regenerate the list of MM tree entry names to hide from non-admin users
  $hidden_names = array(MM_ENTRY_NAME_DEFAULT_USER, MM_ENTRY_NAME_DISABLED_USER);
  $hidden_names = array_merge($hidden_names, mm_module_invoke_all('mm_hidden_user_names'));
  variable_set('mm_hidden_user_names', $hidden_names);
  // debug_add_dump($callbacks);

  // Regenerate the custom page display list
  _mm_showpage_router(TRUE);
}

/**
 * Implements hook_node_view().
 */
function monster_menus_node_view($node, $view_mode) {
  if (!isset($node)) return;

  mm_node_all_nodes_hook('view', $node, $view_mode);

  $_mm_mmtid_of_node = &drupal_static('_mm_mmtid_of_node');
  $_mm_page_args = &drupal_static('_mm_page_args');

  if (!empty($node->nid) && !mm_content_user_can_node($node, MM_PERMS_READ)) {
    mm_node_load_fail($node, $view_mode == 'teaser');
  }
  else {
    // If this is a view rendering a node not on an MM page, allow the
    // Edit/Delete/etc. links to appear.
    if (isset($node->view) && isset($node->view->style_plugin) && isset($node->view->style_plugin->row_plugin) && $node->view->style_plugin->row_plugin->options['links']) {
      $_mm_mmtid_of_node[$node->nid] = TRUE;
    }

    // The comment module's hook_node_view() uses node_is_page(), which
    // requires that the node be displayed all by itself with a node/% URL.
    // Therefore, we need to load any comments here.
    if ($node->comment && $view_mode == 'full' && module_exists('comment') && !node_is_page($node) && empty($node->in_preview)) {
      if (variable_get('mm_show_count_instead_of_comments', FALSE)) {
        $args = arg();
        if (($count = count($args)) >= 2 && $args[$count - 2] == 'node' && $args[$count - 1] == $node->nid) {
          $node->content['comments'] = comment_node_page_additions($node);
          unset($node->content['links']['comment']['#links']['comment_forbidden']);
        }
        elseif (_mm_content_comments_readable($node)) {
          // Redo the comments using the teaser view, to get the proper links
          comment_node_view($node, 'teaser');
        }
        elseif ($node->comment_count > 0) {
          $node->content['links']['comment']['#links']['comment_forbidden'] = array('title' => theme('comment_post_forbidden', array('node' => $node, 'read' => TRUE)), 'html' => TRUE);
        }
      }
      else {
        $node->content['comments'] = comment_node_page_additions($node);
      }
    }
  }

  $node->title = mm_ui_hide_node_title($node->title);

  $node_types = array_keys(node_type_get_names());
  _mm_menu_active_item();
  if (isset($_mm_mmtid_of_node[$node->nid]) && array_search($node->type, $node_types) !== FALSE) {
    $defaults = $links = array();
    if (!empty($_GET['destination'])) {
      $defaults = array('query' => array('destination' => $_GET['destination']));
    }

    $pa = empty($_mm_page_args) ? 'node/' : "$_mm_page_args/node/";

    $query = db_select('node_revision', 'r');
    $query->join('node', 'n', 'n.nid = r.nid');
    $query->condition('r.nid', $node->nid, '=');
    $query->addField('n', 'vid', 'current_vid');
    $query->addExpression('COUNT(*)', 'count_revisions');
    $revisions = $query->execute()->fetchObject();

    $is_latest = $revisions->current_vid == $node->vid;
    if ($is_latest && node_access('update', $node)) {
      $links[] = $defaults + array('title' => t('Edit'), 'href' => $pa . $node->nid . '/edit');
    }

    if (_mm_menu_access_node_delete($node)) {
      if (_mm_menu_access_node_restore($_mm_mmtid_of_node[$node->nid], $node)) {
        $links[] = $defaults + array(
          'title' => t('Restore'),
          'href' => $pa . $node->nid . '/restore');
      }
      if ($is_latest) {
        $links[] = $defaults + array(
          'title' => mm_content_node_is_recycled($node) ? t('Delete permanently') : t('Delete'),
          'href' => $pa . $node->nid . '/delete');
      }
    }

    if (node_access('update', $node) && node_access('view', $node) && (user_access('view revisions') || (user_access('administer nodes') && user_access('bypass node access'))) && $revisions->count_revisions > 1) {
      $links[] = $defaults + array('title' => t('Revisions'),
          'href' => $pa . $node->nid . '/revisions');
      if (!$is_latest) {
        $links[] = $defaults + array('title' => t('Revert to this revision'),
            'href' => $pa . $node->nid . '/revisions/' . $node->vid . '/revert');
        $links[] = $defaults + array('title' => t('Delete this revision'),
            'href' => $pa . $node->nid . '/revisions/' . $node->vid . '/delete');
      }
    }

    if ($links) {
      $node->content['links'][$node->type] = array(
        '#links' => $links,
        '#attributes' => array('class' => array('links', 'inline')),
      );
    }
  }

  if ($view_mode == 'rss' && isset($node->nid)) {
    $node->created = $node->changed;
  }
}

/**
 * Implements hook_boot().
 */
function monster_menus_boot() {
  global $user;

  if ($user->uid > 0) {
    mm_set_user_roles($user);
  }

  // Rewrite the URL stored in $_GET so that MM aliases point to the correct location
  require_once DRUPAL_ROOT . '/includes/unicode.inc';
  $old_q = $new_q = isset($_GET['q']) ? $_GET['q'] : '';
  mm_module_invoke_all_array('url_inbound_alter', array(&$new_q, $new_q, NULL));
  if ($new_q != '' || $_GET['q'] == mm_home_path() || $_GET['q'] == mm_home_path() . '/') {
    $_GET['q'] = $new_q;
    if ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD') {
      // If the URL contains mm/N or just N, redirect to the appropriate alias
      if (preg_match('{^(mm/)?\d+/?$}', $old_q)) {
        require_once DRUPAL_ROOT . '/includes/path.inc';
        require_once DRUPAL_ROOT . '/includes/common.inc';
        mm_module_invoke_all_array('url_outbound_alter', array(&$new_q, &$dummy, $new_q));
        if ($new_q != $old_q) {
          module_load_include('module', 'filter', 'filter');
          $GLOBALS['devel_shutdown'] = TRUE;    // prevent a missing function problem
          // 'language' is necessary because global $language_url isn't initialized yet
          drupal_goto($new_q, array('query' => drupal_get_query_parameters($_GET, array('q')), 'language' => LANGUAGE_NONE));
        }
      }
    }
  }
}

/**
 * Implements hook_custom_theme().
 */
function monster_menus_custom_theme() {
  mm_parse_args($mmtids, $oarg_list);
  if (count($mmtids)) {
    $select = db_select('mm_tree', 't');
    $select->fields('t', array('theme'));
    $select->addExpression('LENGTH(sort_idx)', 'tree_depth');
    $select->condition('t.mmtid', $mmtids)
      ->condition('t.theme', '', '<>')
      ->orderBy('tree_depth', 'DESC')
      ->range(0, 1);
    if ($theme = $select->execute()->fetchField()) {
      return $theme;
    }
  }
}

/**
 * Implements hook_url_inbound_alter().
 */
function monster_menus_url_inbound_alter(&$path, $original_path, $path_language) {
  $cache = &drupal_static(__FUNCTION__);

  // remove empty '//' elements
  $original_path = preg_replace('{/+}', '/', $original_path);
  $original_path = trim($original_path, '/');

  $path = $original_path;
  if ($original_path == '' || $original_path == mm_home_path()) {
    $path = mm_home_path();
    return;
  }

  if (isset($cache[$original_path])) {
    $path = $cache[$original_path];
    return;
  }
//   debug_add("* from: $original_path");

  $elems = explode('/', $original_path);
  $in_mm = FALSE;
  if ($elems[0] == 'mm') {
    $in_mm = TRUE;
    array_shift($elems);
  }

  if ($elems[0] == mm_home_mmtid()) {
    $in_mm = TRUE;
    $this_mmtid = $parent = mm_home_mmtid();
    array_shift($elems);
  }

  if (count($elems) >= 2 && ($elems[0] == mm_content_users_alias() || is_numeric($elems[0]) && $elems[0] == mm_content_users_mmtid()) && strlen($elems[1]) == 1 && variable_get('mm_use_virtual_user_dir', TRUE)) {
    $in_mm = TRUE;
    $alias = ctype_alpha($elems[1][0]) ? strtoupper($elems[1][0]) : '~';
    array_splice($elems, 0, 2);
    $this_mmtid = $parent = count($elems) ? mm_content_users_mmtid() : -ord($alias);
  }

  $joins = $wheres = $numeric = $args = $args_at_level = array();
  $a = 0;
  $reserved = variable_get('mm_reserved_alias', array());
  $max = min(count($elems), variable_get('mm_content_mysql_max_joins', MM_CONTENT_MYSQL_MAX_JOINS));
  for ($i = 0; $i < $max; $i++) {
    $elem = $elems[$i];
    $numeric[$i] = FALSE;
    if (!$in_mm && $i == 0 && ($elem == 'settings' || $elem == 'contents')) {
      $in_mm = TRUE;
      $this_mmtid = mm_home_mmtid();
      break;
    }
    elseif (!in_array($elem, $reserved)) {
      $n = count($joins);
      $nprev = $n - 1;
      $joins[] = "{mm_tree} t$n" . ($n ? " ON t$n.parent = t$nprev.mmtid" : '');
      $prefix = $n ? '' : (empty($parent) ? '' : "t0.parent = $parent AND ");
      $middle = $n ? '' : (empty($parent) ? 't0.parent IN(1, ' . mm_home_mmtid() . ') AND ' : '');
      $numeric[$i] = is_numeric($elem) && intval($elem) == $elem && $elem != 0;
      $args[':a' . $a++] = $elem;
      if ($numeric[$i] && $elem > 0) {
        $wheres[] = "{$prefix}(t$n.mmtid = :a" . ($a - 1) . " OR {$middle}t$n.alias = :a$a)";
        $args[':a' . $a++] = $elem;
        $args_at_level[$i] = 2;
      }
      else {
        $wheres[] = "{$prefix}{$middle}t$n.alias = :a" . ($a - 1);
        $args_at_level[$i] = 1;
      }
    }
    else break;
  }

  while ($joins) {
    $n = count($joins) - 1;
    $new_mmtid = db_query("SELECT t$n.mmtid FROM " . join(' INNER JOIN ', $joins) . ' WHERE ' . join(' AND ', $wheres) . " ORDER BY t$n.alias LIMIT 1", $args)->fetchField();
    array_pop($joins);
    array_pop($wheres);
    $was_numeric = array_pop($numeric);
    if ($new_mmtid) {
      $in_mm = TRUE;
      $this_mmtid = $new_mmtid;
      break;
    }
    elseif ($was_numeric) {
      if ($elems[0] < 0) {
        $this_mmtid = $elems[0];
        $in_mm = TRUE;
        break;
      }
      elseif (!$joins) {
        $site_404 = variable_get('site_404', '');
        if ($site_404 && $site_404 != $original_path) {
          // $path is already a reference here
          mm_module_invoke_all_array('url_inbound_alter', array($path, $site_404, $path_language));
          return;
        }
        break;
      }
    }
    // There can't be any extra args, so remove what's not needed
    if ($popped = array_pop($args_at_level)) {
      array_splice($args, -$popped);
    }
    $i--;
  }

  if ($in_mm) {
    $elems = array_slice($elems, $i);
    array_unshift($elems, "mm/$this_mmtid");
    $path = implode('/', $elems);
  }
  $cache[$original_path] = $path;
//   debug_add("* to: $path ");
}

/**
 * Implements hook_url_outbound_alter().
 */
function monster_menus_url_outbound_alter(&$path, &$options, $unused) {
  $_mm_custom_url_rewrite_outbound_cache = &drupal_static('_mm_custom_url_rewrite_outbound_cache', array());
  $original_path = $path;

  $cache_id = $original_path . ':' . (isset($options['query']) ? $options['query'] : '');
  if (isset($_mm_custom_url_rewrite_outbound_cache[$cache_id])) {
    $path = $_mm_custom_url_rewrite_outbound_cache[$cache_id];
    return;
  }

//    debug_add("** from: $path");
  if (($arg0 = mm_parse_args($mmtids, $oarg_list, $this_mmtid, $path)) == 'mm') {
    if ($mmtids && $mmtids[0] == mm_home_mmtid()) {
      if (count($mmtids) == 1 && count($oarg_list)) {
        $_mm_custom_url_rewrite_outbound_cache[$cache_id] = $path;
        return;
      }
      array_shift($mmtids);
    }

    $test_path = "mm/$this_mmtid";
    if (isset($_mm_custom_url_rewrite_outbound_cache[$test_path])) {
      $path = implode('/', array_merge(array($_mm_custom_url_rewrite_outbound_cache[$test_path]), $oarg_list));
      $_mm_custom_url_rewrite_outbound_cache[$original_path] = $path;
      return;
    }

    $tree = mm_content_get($mmtids);

    foreach ($mmtids as $i => $mmtid)
      foreach ($tree as $key => $item)
        if ($item->mmtid == $mmtid) {
          if ($item->alias != '') $mmtids[$i] = $item->alias;
          unset($tree[$key]);
          break;
        }

    $path = implode('/', array_merge($mmtids, $oarg_list));

    mm_module_invoke_all_array('mm_url_rewrite_outbound', array($this_mmtid, &$path, &$options, $original_path));
  }
  elseif ($path != '') {
    $curr_page = _mm_menu_active_item();
    $link_page = _mm_menu_active_item($path);

    $mmtid = isset($curr_page->mmtid) && !is_null($curr_page->nid) ? $curr_page->mmtid : (isset($link_page->mmtid) ? $link_page->mmtid : NULL);
    if ($mmtid && !is_null($link_page->nid)) {
      $path = implode('/', array_merge(array('mm', $mmtid, $arg0), $oarg_list));
    }

    mm_module_invoke_all_array('mm_url_rewrite_outbound', array($mmtid, &$path, &$options, $original_path));

    if ($mmtid && $path != $original_path) {
      // $path and $options are already references, so no need to use &
      drupal_alter('url_outbound', $path, $options, $original_path);
    }
  }
  // Don't use $cache_id here, since $options['query'] may have changed
  $_mm_custom_url_rewrite_outbound_cache[$original_path . ':' . (isset($options['query']) ? $options['query'] : '')] = $path;
//    debug_add("** to: $path ");
}

/**
 * Implements hook_block_info().
 */
function monster_menus_block_info() {
  return mm_content_get_blocks();
}

/**
 * Implements hook_block_view().
 */
function monster_menus_block_view($delta = '') {
  $blocks = mm_content_get_blocks();
  mm_parse_args($mmtids, $oarg_list, $this_mmtid);
  $show_arr = mm_module_invoke_all('mm_menus_block_shown', $this_mmtid, $delta);
  if ($show_arr && array_product($show_arr) == 0) return;
  if (isset($blocks[$delta])) {
    $i = 0;
    $block['content'] = array();
    if (!$mmtids) $mmtids = array(mm_home_mmtid());

    // Search up the path, looking for the bottom-most block with an
    // entry in mm_tree_block.
    if ($starters = mm_content_get_blocks_at_mmtid($mmtids, $delta, TRUE)) {
      $starter = array_pop($starters);
      $start = $starter['mmtid'];

      $b = $blocks[$delta];
      if ($b['show_node_contents']) {
        $here = NULL;
      }
      else {
        $here = array($start);
        if (($i = array_search($start, $mmtids)) !== FALSE)
          $here = array_slice($mmtids, $i);
      }

      $params = array(
        MM_GET_TREE_ADD_TO_CACHE => TRUE,
        MM_GET_TREE_BLOCK => $delta,
        MM_GET_TREE_DEPTH => $starter['max_depth'],
        MM_GET_TREE_HERE => $here,
        MM_GET_TREE_PRUNE_PARENTS => TRUE,
        MM_GET_TREE_RETURN_NODE_COUNT => variable_get('mm_hide_empty_pages', FALSE),
        MM_GET_TREE_RETURN_PERMS => TRUE,
        MM_GET_TREE_SORT => TRUE,
      );
      $tree = mm_content_get_tree($start, $params);
      $can_edit = $tree[0]->perms[MM_PERMS_WRITE] || $tree[0]->perms[MM_PERMS_SUB] || $tree[0]->perms[MM_PERMS_APPLY];

      if ($b['title_is_cat']) $name = $tree[0]->name;

      if ($b['show_node_contents']) {
        $prev = $tree[0]->level;

        $block['content'] = array();
        foreach ($tree as $t) {
          if (!$t->perms[MM_PERMS_IS_RECYCLED]) {
            if ($t->level <= $prev) {
              array_splice($mmtids, $prev - $t->level - 1);
            }

            $mmtids[] = $t->mmtid;

            $block['content'][] = _mm_render_pages($mmtids, array(), $err, TRUE, $b['allow_rss'], $delta);
            $prev = $t->level;
          }
        }
      }
      else {
        $base = $b['title_is_cat'] ? 1 : 0;

        $parents = array('mm');
        if ($tree[$base]->parent != 1) {
          $parents[] = $tree[$base]->parent;
        }

        $content = mm_content_render_tree($tree, $base, $path, $parents);

        if ($content['body'] != '' || $b['title_is_cat'] && $can_edit) {
          $block['content'] = array(
            '#markup' => $content['prefix'] . $content['body'] . $content['suffix'],
          );
        }
      }

      if ($b['title_is_cat'] || $b['show_node_contents']) {
        $edit_links = array();
        $contextual = module_exists('contextual') && user_access('access contextual links');
        if ($can_edit) {
          $href = mm_content_get_mmtid_url($start);
          if ($contextual) {
            // The contextual menu code doesn't work out of the box with this
            // link, so hack it in monster_menus_contextual_links_view_alter().
            // This also lets us set a proper title.
            $edit_links['monster_menus-0'] = array(
              $href,
              array(),
              t('View this page'),
            );
            $edit_links['monster_menus-1'] = array(
              $href . '/settings/edit',
              array(),
              t('Page settings'),
            );
          }
          else {
            $edit_links[] = array(
              'title' => t('Edit'),
              'href' => $href . ($b['show_node_contents'] ? '' : '/settings/edit'),
            );
          }
        }

        foreach ($starters as $other) {
          if (($perms = mm_content_user_can($other['mmtid'])) && ($perms[MM_PERMS_WRITE] || $perms[MM_PERMS_SUB] || $perms[MM_PERMS_APPLY])) {
            $href = mm_content_get_mmtid_url($other['mmtid']) . ($b['show_node_contents'] ? '' : '/settings/edit');
            if ($contextual) {
              $edit_links['monster_menus-' . count($edit_links)] = array(
                $href,
                array(),
                $b['show_node_contents'] ? t('View hidden page') : t('Hidden page settings'),
              );
            }
            else {
              $edit_links[] = array(
                'title' => t('Edit hidden'),
                'href' => $href,
              );
            }
          }
        }

        if (count($edit_links)) {
          if ($contextual) {
            $block['content']['#contextual_links'] = $edit_links;
          }
          else {
            array_unshift($block['content'], array(
              '#theme' => 'links__mm_block_edit',
              '#prefix' => '<div class="link-wrapper">',
              '#suffix' => '</div>',
              '#attributes' => array('class' => array('links inline')),
              '#links' => $edit_links,
            ));
          }
        }
      }
    }

    $block['subject'] = isset($name) ? $name : (isset($b) && isset($b['title']) ? $b['title'] : '');
  }
  else {
    $block = array('content' => array(), 'subject' => '');
  }
  return $block;
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function monster_menus_contextual_links_view_alter(&$element, $items) {
  // The contextual menu code doesn't work out of the box with our links, so
  // so hack it here. This also lets us set a proper title.
  foreach ($element['#contextual_links'] as $key => $entry) {
    if (!strncmp($key, 'monster_menus-', 14) && !isset($element['#links'][$key])) {
      $element['#links'][$key] = array(
        'title' => $entry[2],
        'href' => $entry[0],
      );
    }
  }
}

/**
 * Implements hook_cron().
 *
 * Updates the table containing all results of virtual group queries; flushes
 * any recycled content that has expired; updates the virtual user directory cache
 */
function monster_menus_cron() {
  // update any parts of the tree with dirty sort indices
  mm_content_update_sort(1, FALSE);

  // regenerate mm_virtual_group if needed
  mm_regenerate_vgroup();

  // Remove unneeded cache entries.
  db_delete('mm_access_cache')->condition('expire', REQUEST_TIME, '<')->execute();

  // Keep track of the average time between cron runs, so that we can tell the
  // user in mm_content_get_recycle_autodel_time() when recycling bins are likely to be
  // automatically emptied
  //
  // average_time_between_runs = (mm_cron_run_last - mm_cron_run_since) / mm_cron_run_count
  //      likely_next_cron_run = mm_cron_run_last + average_time_between_runs
  //
  variable_set('mm_cron_run_count', variable_get('mm_cron_run_count', -1) + 1);
  if (variable_get('mm_cron_run_since', 0) == 0)
      variable_set('mm_cron_run_since', REQUEST_TIME);
  variable_set('mm_cron_run_last', REQUEST_TIME);

  global $user;
  drupal_save_session(FALSE);  // in case of error, don't save session as wrong user
  $old_user = $user;
  $user = user_load(1);        // run as admin user
  mm_content_empty_all_bins(MM_CRON_EMPTY_BINS_LIMIT);
  // other tasks that must run as admin can be added here
  $user = $old_user;           // reset user from above
  drupal_save_session(TRUE);   // re-enable session saving

  // Clear out the group editing temp table
  // DELETE FROM {mm_group_temp} m WHERE
  //   (SELECT COUNT(*) = 0 FROM {sessions} s WHERE s.sid = m.sessionid)
  $count = db_select('sessions');
  $count->addExpression('COUNT(*) = 0');   // countQuery() won't work here
  $count->where('sid = mm_group_temp.sessionid');
  db_delete('mm_group_temp')
    ->condition($count)
    ->execute();

  // add any future tasks here, outside of admin user block
}

/**
 * Implements hook_page_alter().
 */
function monster_menus_page_alter(&$page) {
  // Unfortunately, we can't just add the footer content here, since it might
  // not be available yet. So add an element with a theme function that will
  // append the actual code later on.
  $page['page_bottom']['monster_menus'] = array('#theme' => 'mm_page_footer');
}

/**
 * Implements hook_exit().
 */
function monster_menus_exit($main = 0) {
  // Process any queued changes to the sort index
  mm_content_update_sort_queue();

  // Get the list of pages whose permissions or location in the tree have
  // changed and remove entries from mm_access_cache for all nodes appearing on
  // these pages and their children.
  $mmtids = _mm_content_clear_access_cache();
  if (!empty($mmtids)) {
    // db_delete() doesn't support JOINs, hence this mess.
    // DELETE FROM {mm_access_cache} WHERE
    //   nid IN (SELECT n.nid FROM {mm_node2tree} n
    //     INNER JOIN {mm_tree_parents} p ON p.mmtid = n.mmtid
    //     WHERE p.mmtid IN(:mmtids) OR p.parent IN(:mmtids))
    $inner = db_select('mm_node2tree', 'n');
    $inner->join('mm_tree_parents', 'p', 'p.mmtid = n.mmtid');
    $inner->condition(db_or()
      ->condition('p.mmtid', $mmtids, 'IN')
      ->condition('p.parent', $mmtids, 'IN')
    );
    $inner->fields('n', array('nid'));
    db_delete('mm_access_cache')
      ->condition('nid', $inner, 'IN')
      ->execute();
  }
}

/**
 * Implements hook_user_delete().
 */
function monster_menus_user_delete(&$account) {
  foreach (mm_module_implements('mm_user_delete') as $module) {
    if (call_user_func_array($module . '_mm_user_delete', array(&$account))) return;
  }

  if ($account->user_mmtid) mm_content_move_to_disabled($account->user_mmtid);
  db_delete('mm_group')->condition('uid', $account->uid)->execute();
  db_delete('mm_virtual_group')->condition('uid', $account->uid)->execute();
  db_delete('mm_tree_bookmarks')->condition('uid', $account->uid)->execute();

  // Remove cached access rights.
  db_delete('mm_access_cache')->condition('uid', $account->uid)->execute();
}

/**
 * Implements hook_user_insert().
 */
function monster_menus_user_insert(&$edit, $account, $category) {
  foreach (mm_module_implements('mm_user_insert') as $module) {
    if (call_user_func_array($module . '_mm_user_insert', array(&$edit, $account, $category))) return;
  }

  // Make sure the user has a home directory, if applicable.
  mm_content_add_user($account);
}

/**
 * Implements hook_user_update().
 */
function monster_menus_user_update(&$edit, $account, $category) {
  foreach (mm_module_implements('mm_user_update') as $module) {
    if (call_user_func_array($module . '_mm_user_update', array(&$edit, $account, $category))) return;
  }

  // Make sure the user has a home directory, if applicable.
  mm_content_add_user($account);
}

/**
 * Implements hook_user_load().
 */
function monster_menus_user_load($users) {
  // Note: $users is already a reference, so no need to use &$users above
  foreach (mm_module_implements('mm_user_load') as $module) {
    if (call_user_func_array($module . '_mm_user_load', array($users))) return;
  }

  global $user;
  foreach ($users as $uid => $account) {
    if ($uid > 0) {
      $home = mm_content_get(array('flags' => array('user_home' => $uid)));
      if (isset($home[0]) && is_object($home[0])) {
        $users[$uid]->user_mmtid = $home[0]->mmtid;
        if ($account->uid == $user->uid) $user->user_mmtid = $home[0]->mmtid;
      }
      mm_set_user_roles($users[$uid]);
    }
  }
}

/**
 * Implements hook_node_load().
 */
function monster_menus_node_load($nodes, $types) {
  $mmtids_to_load = array();
  $nids = array_keys($nodes);
  $mmtids_containing_node = mm_content_get_by_nid($nids);
  foreach ($nids as $nid) {
    $node = &$nodes[$nid];

    mm_node_all_nodes_hook('load', $node);

    if (isset($mmtids_containing_node[$nid])) {
      $mmtids_to_load = array_merge($mmtids_to_load, $mmtids_containing_node[$nid]);
    }

    $node->mm_catlist = array();
    $node->others_w = FALSE;
    $node->users_w = $node->groups_w = array();
    $node->recycle_bins = $node->recycle_from_mmtids = array();
  }

  $result = db_select('mm_node_write', 'w')
    ->fields('w', array('gid', 'nid'))
    ->condition('w.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    if ($r->gid == 0) {
      $nodes[$r->nid]->others_w = TRUE;
    }
    elseif ($r->gid < 0) {
      $nodes[$r->nid]->users_w = array_fill_keys(mm_content_get_uids_in_group($r->gid), '');
    }
    else {
      $nodes[$r->nid]->groups_w[$r->gid] = '';
    }
  }

  $result = db_select('mm_recycle', 'r')
    ->fields('r')
    ->condition('r.type', 'node')
    ->condition('r.id', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->id];
    // Display the oldest recycle date to the user.
    if (!isset($node->recycle_date) || $r->recycle_date < $node->recycle_date) {
      $node->recycle_date = $r->recycle_date;
    }
    $node->recycle_bins[] = $r->bin_mmtid;
    $node->recycle_from_mmtids[] = $r->from_mmtid;
  }

  $result = db_select('mm_node_info', 'i')
    ->fields('i', array('show_node_info', 'comments_readable', 'nid'))
    ->condition('i.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->nid];

    $node->show_node_info = $r->show_node_info;
    $node->comments_readable = $r->comments_readable;
  }

  $result = db_select('mm_node_schedule', 's')
    ->fields('s', array('publish_on', 'unpublish_on', 'set_change_date', 'nid'))
    ->condition('s.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->nid];

    $node->publish_on = $r->publish_on;
    $node->unpublish_on = $r->unpublish_on;
    $node->set_change_date = $r->set_change_date;
  }

  // Fetch the names of all needed pages at once.
  $names = array();
  foreach (mm_content_get(array_unique($mmtids_to_load)) as $mm_tree) {
    $names[$mm_tree->mmtid] = mm_content_expand_name($mm_tree->name);
  }

  // Cleanup
  foreach ($nids as $nid) {
    $node = &$nodes[$nid];

    // Populate page list
    if (isset($mmtids_containing_node[$nid])) {
      foreach ($mmtids_containing_node[$nid] as $mmtid) {
        $node->mm_catlist[$mmtid] = $names[$mmtid];
      }
    }

    $node->recycle_bins = array_unique($node->recycle_bins);
    $node->recycle_from_mmtids = array_unique($node->recycle_from_mmtids);
  }
}

/**
 * Implements hook_node_validate().
 */
function monster_menus_node_validate($node, $form, &$form_state) {
  mm_node_all_nodes_hook('validate', $node, $form, $form_state);

  if (!empty($node->mm_catlist) && is_array($node->mm_catlist) && count($node->mm_catlist)) {
    foreach ($node->mm_catlist as $mmtid => $name) {
      if (!$mmtid || !mm_content_user_can($mmtid, MM_PERMS_APPLY)) {
        form_set_error('mm_catlist', t('You are not allowed to assign content to the page %cat.', array('%cat' => $name)));
      }
      elseif (mm_content_is_archive($mmtid)) {
        form_set_error('mm_catlist', t('The page %cat is an archive of another page. Assign the content to the main page, and the archive will be updated automatically.', array('%cat' => $name)));
      }
    }
  }
  elseif (empty($node->mm_catlist_restricted)) {
    form_set_error('mm_catlist', t('You must assign this content to at least one page.'));
  }

  if (isset($node->owner) && user_access('administer all menus')) {
    _mm_ui_verify_userlist($node->owner, 'owner');
  }

  if (empty($node->mm_skip_perms)) {
    if (isset($node->groups_w) && is_array($node->groups_w)) {
      foreach ($node->groups_w as $gid => $name) {
        if ($gid && !mm_content_user_can($gid, MM_PERMS_APPLY)) {
          form_set_error('groups_w', t('You do not have permission to use the group %grp.', array('%grp' => $name)));
        }
      }
    }

    if (isset($node->users_w) && is_array($node->users_w)) {
      _mm_ui_verify_userlist($node->users_w, 'users_w');
    }
  }

  if (!empty($node->publish_on) && !empty($node->unpublish_on)) {
    $publish_on = strtotime($node->publish_on);
    $unpublish_on = strtotime($node->unpublish_on);
    if ($unpublish_on > 0 && $unpublish_on < $publish_on) {
      form_set_error('unpublish_on', t('You have chosen an unpublish date earlier than the publish date.'));
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function monster_menus_node_presave($node) {
  mm_node_all_nodes_hook('presave', $node);

  if (user_access('administer all menus') && isset($node->owner) && ($account = user_load($node->owner))) {
    $node->uid = $account->uid;
    $node->name = $account->name;
  }

  if (isset($node->all_values_group)) {
    list($groups, $users, $others) = _mm_ui_form_parse_perms((array)$node, FALSE);
    $node->groups_w = array_flip(array_keys($groups));
    $node->users_w = array_flip(array_keys($users));
    $node->others_w = !empty($node->{'node-everyone'});
  }
}

/**
 * Implements hook_node_access().
 */
function monster_menus_node_access($node, $op, $account) {
  $return = mm_node_all_nodes_hook('access', $node, $op, $account);
  if (is_object($node) && $node->nid) {
    $return[] = mm_content_node_access($node, $op, $account) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }

  if (is_array($return)) {
    if (in_array(NODE_ACCESS_DENY, $return, TRUE)) {
      return NODE_ACCESS_DENY;
    }
    elseif (in_array(NODE_ACCESS_ALLOW, $return, TRUE)) {
      return NODE_ACCESS_ALLOW;
    }
  }
}

/**
 * Implements hook_node_update().
 */
function monster_menus_node_update($node) {
  mm_node_all_nodes_hook('update', $node);

  if (!mm_content_node_is_recycled($node)) {
    if (!isset($node->mm_catlist_restricted)) {
      $node->mm_catlist_restricted = array();
    }

    $list = array_merge(array_keys($node->mm_catlist), $node->mm_catlist_restricted);
    if ($list) {
      db_delete('mm_node_reorder')
        ->condition('nid', $node->nid)
        ->condition('mmtid', $list, 'NOT IN')
        ->execute();
    }
    else {
      db_delete('mm_node_reorder')
        ->condition('nid', $node->nid)
        ->execute();
    }

    // Remove cached access rights.
    db_delete('mm_access_cache')->condition('nid', $node->nid)->execute();
  }

  _monster_menus_node_update_or_insert($node, FALSE);
}

/**
 * Implements hook_node_insert().
 */
function monster_menus_node_insert($node) {
  mm_node_all_nodes_hook('insert', $node);
  _monster_menus_node_update_or_insert($node, TRUE);
}

function _monster_menus_node_update_or_insert($node, $insert) {
  if (!mm_content_node_is_recycled($node)) {
    db_delete('mm_node2tree')
        ->condition('nid', $node->nid)
        ->execute();
    if (is_array($node->mm_catlist)) {
      if (!isset($node->mm_catlist_restricted)) {
        $node->mm_catlist_restricted = array();
      }

      foreach (array_merge(array_keys($node->mm_catlist), $node->mm_catlist_restricted) as $mmtid) {
        db_insert('mm_node2tree')
          ->fields(array(
            'nid' => $node->nid,
            'mmtid' => $mmtid,
          ))
          ->execute();
      }
    }
  }

  mm_content_set_node_perms($node);

  if (empty($node->show_node_info)) {
    $node->show_node_info = FALSE;
  }
  if (empty($node->comments_readable)) {
    $node->comments_readable = FALSE;
  }

  db_merge('mm_node_info')
    ->key(array('nid' => $node->nid))
    ->fields(array(
      'show_node_info' => intval($node->show_node_info),
      'comments_readable' => $node->comments_readable,
    ))
    ->execute();

  if (empty($node->publish_on)) {
    $node->publish_on = 0;
  }
  else {
    $node->publish_on = strtotime($node->publish_on);
    if ($node->publish_on <= 0) $node->publish_on = 0;
  }

  if (empty($node->unpublish_on)) {
    $node->unpublish_on = 0;
  }
  else {
    $node->unpublish_on = strtotime($node->unpublish_on);
    if ($node->unpublish_on <= 0) $node->unpublish_on = 0;
  }

  if (empty($node->set_change_date)) {
    $node->set_change_date = 0;
  }

  if ($node->publish_on || $node->unpublish_on || $node->set_change_date) {
    db_merge('mm_node_schedule')
      ->key(array('nid' => $node->nid))
      ->fields(array(
        'publish_on' => $node->publish_on,
        'unpublish_on' => $node->unpublish_on,
        'set_change_date' => $node->set_change_date,
      ))
      ->execute();
  }
  elseif (!$insert) {
    db_delete('mm_node_schedule')
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_node_revision_delete().
 */
function monster_menus_node_revision_delete($node) {
  mm_node_all_nodes_hook('revision_delete', $node);

  // Remove cached access rights.
  db_delete('mm_access_cache')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_node_delete().
 */
function monster_menus_node_delete($node) {
  mm_node_all_nodes_hook('delete', $node);

  db_delete('mm_node2tree')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_node_reorder')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_recycle')
    ->condition('type', 'node')
    ->condition('id', $node->nid)
    ->execute();
  db_delete('mm_node_info')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_node_schedule')
    ->condition('nid', $node->nid)
    ->execute();
  _mm_ui_delete_node_groups($node, TRUE);
  if (isset($node->recycle_bins) && is_array($node->recycle_bins)) {
    foreach ($node->recycle_bins as $bin) {
      mm_content_clear_caches($bin);
      mm_content_delete_bin($bin);
    }
  }
}

/**
 * Implements hook_preprocess_username().
 *
 * @param $variables
 *   An associative array containing:
 *   - account: The user object to format.
 *   - name: The user's name, sanitized.
 *   - extra: Additional text to append to the user's name, sanitized.
 *   - link_path: The path or URL of the user's profile page, home page, or
 *     other desired page to link to for more information about the user.
 *   - link_options: An array of options to pass to the l() function's $options
 *     parameter if linking the user's name to the user's page.
 *   - attributes_array: An array of attributes to pass to the
 *     drupal_attributes() function if not linking to the user's page.
 */
function monster_menus_preprocess_username(&$variables) {
  $account = $variables['account'];
  $uid = isset($account->uid) ? $account->uid : 0;
  $name = isset($account->name) ? $account->name : '';

  if (!empty($uid) && !empty($name) && user_access('access user profiles')) {
    $variables['name'] = mm_content_uid2name($uid, 'fml', NULL, $hover);
    if (!empty($hover)) {
      $variables['link_attributes']['title'] = $hover;
    }
  }
}

/**
 * Implements hook_library().
 */
function monster_menus_library() {
  $mm_basepath = drupal_get_path('module', 'monster_menus');
  $libraries['mm'] = array(
    'title' => 'MM',
    'website' => 'http://drupal.org/node/1118296',
    'version' => '1.0',
    'js' => array(
       "$mm_basepath/js/mm.js" => array(
        'scope' => 'header',
      ),
    ),
    'css' => array(
      "$mm_basepath/css/mm.css" => array(),
    ),
  );
  $libraries['mm_browser'] = array(
    'title' => 'MM Browser',
    'website' => 'http://drupal.org/node/1118296',
    'version' => '1.0',
    'js' => array(
      "$mm_basepath/js/mm_browser.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/css/mm_browser.css" => array(),
    ),
  );
  // Used by mm_browser.inc
  $libraries['jsTree'] = array(
    'title' => 'jsTree',
    'website' => 'http://www.jstree.com/',
    'version' => '1.0-rc1',
    'js' => array(
      "$mm_basepath/libraries/jsTree/jquery.jstree.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/libraries/jsTree/source/tree_component.css" => array(),
    ),
  );
  // Used by mm_browser.inc
  $libraries['fg.menu'] = array(
    'title' => 'fg.menu',
    'website' => 'http://www.filamentgroup.com/lab/jquery_ipod_style_and_flyout_menus/',
    'version' => '3.0',
    'js' => array(
      "$mm_basepath/libraries/fg.menu.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/libraries/fg.menu.css" => array(),
    ),
    'dependencies' => array(
      array('system', 'ui'),
    ),
  );
  $libraries['splitter'] = array(
    'title' => 'Splitter',
    'website' => 'http://methvin.com/splitter/',
    'version' => '1.5.1',
    'js' => array(
      "$mm_basepath/libraries/splitter.js" => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery.cookie'),
    ),
  );
  $libraries['dataTables'] = array(
    'title' => 'Data Tables',
    'website' => 'http://www.datatables.net/',
    'version' => '1.7.4',
    'js' => array(
      "$mm_basepath/libraries/jquery.dataTables.min.js" => array(),
    ),
  );
  $libraries['xregexp'] = array(
    'title' => 'XRegExp',
    'website' => 'http://xregexp.com',
    'version' => '1.5.0',
    'js' => array(
      "$mm_basepath/libraries/xregexp.js" => array(),
    ),
  );

  return $libraries;
}

/**
 * Implementation of hook_token_info().
 */
function monster_menus_token_info() {
  $tokens = array();

  $type = array(
    'name' => t('MM Tree'),
    'description' => t('Tokens related to the Monster Menus tree.'),
    'needs-data' => 'mm_tree',
  );

  // Unfortunately, drupal_get_schema() strips the field descriptions.
  module_load_include('install', 'monster_menus');
  $schema = module_invoke('monster_menus', 'schema');
  foreach ($schema['mm_tree']['fields'] as $name => $field) {
    if (isset($field['description'])) {
      $tokens[$name] = array(
        'name' => $name,
        'description' => $field['description'],
      );
    }
  }

  $predefined = mm_ui_flags_info();
  $predef_flags = array();
  foreach ($predefined as $module => $flags) {
    foreach ($flags as $name => $info) {
      $predef_flags[] = $name;
      $tokens["flag:$name"] = array(
        'name' => t('MM flag !name from module !module', array('!name' => $name, '!module' => $module)),
        'description' => $info['#description'],
      );
    }
  }
  $result = db_query('SELECT DISTINCT flag FROM {mm_tree_flags}');
  foreach ($result as $r) {
    if (!in_array($r->flag, $predef_flags)) {
      $tokens['flag:' . $r->flag] = array(
        'name' => t('MM flag !name', array('!name' => $r->flag)),
        'description' => t('Monster Menus flag'),
      );
    }
  }

  return array(
    'types' => array('mm_tree' => $type),
    'tokens' => array('mm_tree' => $tokens),
  );
}

/**
 * Implementation of hook_tokens().
 */
function monster_menus_tokens($type, $tokens, $data = NULL, $options = array()) {
  $replacements = array();
  if ($type == 'mm_tree' && isset($data['mm_tree'])) {
    $tree = $data['mm_tree'];

    foreach ($tokens as $name => $raw) {
      if (isset($tree->$name)) {
        $replacements[$raw] = $tree->$name;
      }
    }

    if (is_array($tree->flags) && ($flags_tokens = token_find_with_prefix($tokens, 'flag'))) {
      foreach ($flags_tokens as $flag => $raw) {
        if (isset($tree->flags[$flag])) {
          // Convert empty flags to boolean TRUE
          $replacements[$raw] = empty($tree->flags[$flag]) ? TRUE : $tree->flags[$flag];
        }
        else {
          $replacements[$raw] = FALSE;
        }
      }
    }
  }
  return $replacements;
}
